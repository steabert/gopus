// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package rds

import (
	"context"
)

const addAlbum = `-- name: AddAlbum :exec
INSERT INTO album ( title, artist ) VALUES ( ?, ? )
`

type AddAlbumParams struct {
	Title  string
	Artist string
}

func (q *Queries) AddAlbum(ctx context.Context, arg AddAlbumParams) error {
	_, err := q.db.ExecContext(ctx, addAlbum, arg.Title, arg.Artist)
	return err
}

const addArtist = `-- name: AddArtist :exec
INSERT INTO artist ( name ) VALUES ( ? )
`

func (q *Queries) AddArtist(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, addArtist, name)
	return err
}

const addRecording = `-- name: AddRecording :exec
INSERT INTO recording
  ( path, song, artist, album, cddb, track ) 
VALUES
  ( ?, ?, ?, ?, ?, ?)
`

type AddRecordingParams struct {
	Path   string
	Song   string
	Artist string
	Album  string
	Cddb   string
	Track  int64
}

func (q *Queries) AddRecording(ctx context.Context, arg AddRecordingParams) error {
	_, err := q.db.ExecContext(ctx, addRecording,
		arg.Path,
		arg.Song,
		arg.Artist,
		arg.Album,
		arg.Cddb,
		arg.Track,
	)
	return err
}

const addSong = `-- name: AddSong :exec
INSERT INTO song ( title ) VALUES ( ? )
`

func (q *Queries) AddSong(ctx context.Context, title string) error {
	_, err := q.db.ExecContext(ctx, addSong, title)
	return err
}

const listRecordingsMatchingAlbum = `-- name: ListRecordingsMatchingAlbum :many
SELECT path, song, album, track FROM recording WHERE album LIKE ? ORDER BY album, track
`

type ListRecordingsMatchingAlbumRow struct {
	Path  string
	Song  string
	Album string
	Track int64
}

func (q *Queries) ListRecordingsMatchingAlbum(ctx context.Context, album string) ([]ListRecordingsMatchingAlbumRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecordingsMatchingAlbum, album)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecordingsMatchingAlbumRow
	for rows.Next() {
		var i ListRecordingsMatchingAlbumRow
		if err := rows.Scan(
			&i.Path,
			&i.Song,
			&i.Album,
			&i.Track,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordingsMatchingArtist = `-- name: ListRecordingsMatchingArtist :many
SELECT path, song, album, track FROM recording WHERE artist LIKE ? ORDER BY album, track
`

type ListRecordingsMatchingArtistRow struct {
	Path  string
	Song  string
	Album string
	Track int64
}

func (q *Queries) ListRecordingsMatchingArtist(ctx context.Context, artist string) ([]ListRecordingsMatchingArtistRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecordingsMatchingArtist, artist)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecordingsMatchingArtistRow
	for rows.Next() {
		var i ListRecordingsMatchingArtistRow
		if err := rows.Scan(
			&i.Path,
			&i.Song,
			&i.Album,
			&i.Track,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRecordingsMatchingSong = `-- name: ListRecordingsMatchingSong :many
SELECT path, song, album, track FROM recording WHERE song LIKE ? ORDER BY album, track
`

type ListRecordingsMatchingSongRow struct {
	Path  string
	Song  string
	Album string
	Track int64
}

func (q *Queries) ListRecordingsMatchingSong(ctx context.Context, song string) ([]ListRecordingsMatchingSongRow, error) {
	rows, err := q.db.QueryContext(ctx, listRecordingsMatchingSong, song)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListRecordingsMatchingSongRow
	for rows.Next() {
		var i ListRecordingsMatchingSongRow
		if err := rows.Scan(
			&i.Path,
			&i.Song,
			&i.Album,
			&i.Track,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
